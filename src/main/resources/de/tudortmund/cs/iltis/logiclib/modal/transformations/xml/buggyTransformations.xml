<?xml version="1.0" encoding="UTF-8"?>
<transformations>

    <!-- used to avoid empty disjunctions/conjunctions or those with only 1 child-->
    <clean name="BUGGY_CLEAN" onlyPart="true"></clean>

    <pattern name = "BUGGY_IDEMPOTENCE_TO_TOP_CONJUNCTION" groupId="BUGGY_IDEMPOTENCE_TO_TOP">
        <match>*A∧$X∧*B∧$X∧*C</match>
        <replace>⊤</replace>
        <tests>
            <assertApplicationResult>
                <input>X∧X</input>
                <expect>⊤</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∧X∧B∧X∧C</input>
                <expect>⊤</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∧X∧X∧C</input>
                <expect>⊤</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name = "BUGGY_IDEMPOTENCE_TO_TOP_DISJUNCTION" groupId="BUGGY_IDEMPOTENCE_TO_TOP">
        <match>*A∨$X∨*B∨$X∨*C</match>
        <replace>⊤</replace>
        <tests>
            <assertApplicationResult>
                <input>X∨X</input>
                <expect>⊤</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∨X∨B∨X∨C</input>
                <expect>⊤</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_FORMULA_TO_IMPLICATIONAL_TAUTOLOGY_IMPLICATION" groupId="BUGGY_FORMULA_TO_IMPLICATIONAL_TAUTOLOGY">
        <match>$X</match>
        <replace>$X → $X</replace>
        <tests>
            <assertApplicationResult>
                <input>X</input>
                <expect>X → X</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_FORMULA_TO_IMPLICATIONAL_TAUTOLOGY_EQUIVALENCE" groupId="BUGGY_FORMULA_TO_IMPLICATIONAL_TAUTOLOGY">
        <match>$X</match>
        <replace>$X ↔ $X</replace>
        <tests>
            <assertApplicationResult>
                <input>X</input>
                <expect>X ↔ X</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_CONJUNCTION_WITH_NEGATION_TO_TOP1" groupId="BUGGY_REDUCE_CONJUNCTION_WITH_NEGATION">
        <match>*A∧$X∧*B∧¬$X∧*C</match>
        <replace>⊤</replace>
        <tests>
            <assertApplicationResult>
                <input>X∧¬X</input>
                <expect>⊤</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∧X∧B∧¬X∧C</input>
                <expect>⊤</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_CONJUNCTION_WITH_NEGATION_TO_TOP2" groupId="BUGGY_REDUCE_CONJUNCTION_WITH_NEGATION">
        <match>*A∧¬$X∧*B∧$X∧*C</match>
        <replace>⊤</replace>
        <tests>
            <assertApplicationResult>
                <input>¬X∧X</input>
                <expect>⊤</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∧¬X∧B∧X∧C</input>
                <expect>⊤</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_CONJUNCTION_WITH_NEGATION_TO_SUBFORMULA1" groupId="BUGGY_REDUCE_CONJUNCTION_WITH_NEGATION">
        <match>*A∧$X∧*B∧¬$X∧*C</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>X∧¬X</input>
                <expect>X</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∧X∧B∧¬X∧C</input>
                <expect>X</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_CONJUNCTION_WITH_NEGATION_TO_SUBFORMULA2" groupId="BUGGY_REDUCE_CONJUNCTION_WITH_NEGATION">
        <match>*A∧¬$X∧*B∧$X∧*C</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>¬X∧X</input>
                <expect>X</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∧¬X∧B∧X∧C</input>
                <expect>X</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_CONJUNCTION_WITH_NEGATION_TO_BOTTOM1" groupId="BUGGY_REDUCE_CONJUNCTION_WITH_NEGATION_TO_BOTTOM">
        <match>($X∨$Y)∧(¬$X∨¬$Y)</match>
        <replace>⊥</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∨Y)∧(¬X∨¬Y)</input>
                <expect>⊥</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_CONJUNCTION_WITH_NEGATION_TO_BOTTOM2" groupId="BUGGY_REDUCE_CONJUNCTION_WITH_NEGATION_TO_BOTTOM">
        <match>(¬$X∨¬$Y)∧($X∨$Y)</match>
        <replace>⊥</replace>
        <tests>
            <assertApplicationResult>
                <input>(¬X∨¬Y)∧(X∨Y)</input>
                <expect>⊥</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_DISJUNCTION_WITH_NEGATION_TO_BOTTOM1" groupId="BUGGY_REDUCE_DISJUNCTION_WITH_NEGATION">
        <match>*A∨$X∨*B∨¬$X∨*C</match>
        <replace>⊥</replace>
        <tests>
            <assertApplicationResult>
                <input>X∨¬X</input>
                <expect>⊥</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∨X∨B∨¬X∨C</input>
                <expect>⊥</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_DISJUNCTION_WITH_NEGATION_TO_BOTTOM2" groupId="BUGGY_REDUCE_DISJUNCTION_WITH_NEGATION">
        <match>*A∨¬$X∨*B∨$X∨*C</match>
        <replace>⊥</replace>
        <tests>
            <assertApplicationResult>
                <input>¬X∨X</input>
                <expect>⊥</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∨¬X∨B∨X∨C</input>
                <expect>⊥</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_DISJUNCTION_WITH_NEGATION_TO_SUBFORMULA1" groupId="BUGGY_REDUCE_DISJUNCTION_WITH_NEGATION">
        <match>*A∨$X∨*B∨¬$X∨*C</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>X∨¬X</input>
                <expect>X</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∨X∨B∨¬X∨C</input>
                <expect>X</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_DISJUNCTION_WITH_NEGATION_TO_SUBFORMULA2" groupId="BUGGY_REDUCE_DISJUNCTION_WITH_NEGATION">
        <match>*A∨¬$X∨*B∨$X∨*C</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>¬X∨X</input>
                <expect>X</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∨¬X∨B∨X∨C</input>
                <expect>X</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_DISJUNCTION_WITH_NEGATION_TO_TOP1" groupId="BUGGY_REDUCE_DISJUNCTION_WITH_NEGATION_TO_TOP">
        <match>($X∧$Y)∨(¬$X∧¬$Y)</match>
        <replace>⊤</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∧Y)∨(¬X∧¬Y)</input>
                <expect>⊤</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_DISJUNCTION_WITH_NEGATION_TO_TOP2" groupId="BUGGY_REDUCE_DISJUNCTION_WITH_NEGATION_TO_TOP">
        <match>(¬$X∧¬$Y)∨($X∧$Y)</match>
        <replace>⊤</replace>
        <tests>
            <assertApplicationResult>
                <input>(¬X∧¬Y)∨(X∧Y)</input>
                <expect>⊤</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TOP_IN_FORMULA_DISJUNCTION1_PART" onlyPart="true">
        <match>*X∨⊤∨*Y</match>
        <replace>*X∨*Y</replace>
    </pattern>

    <sequential name="BUGGY_REDUCE_TOP_IN_FORMULA_DISJUNCTION1" groupId="BUGGY_REDUCE_TOP_IN_DISJUNCTION">
        <references>
            <reference name="BUGGY_CLEAN"/>
            <reference name="BUGGY_REDUCE_TOP_IN_FORMULA_DISJUNCTION1_PART"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>X∨⊤</input>
                <expect>X</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>X∨⊤∨¬Y</input>
                <expect>X∨¬Y</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>⊤∨X</input>
                <expect>X</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <pattern name="BUGGY_REDUCE_TOP_IN_FORMULA_CONJUNCTION1" groupId="BUGGY_REDUCE_TOP_IN_CONJUNCTION">
        <match>*X∧⊤∧*Y</match>
        <replace>⊤</replace>
        <tests>
            <assertApplicationResult>
                <input>X∧⊤</input>
                <expect>⊤</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>X∧⊤∧Y</input>
                <expect>⊤</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_BOTTOM_IN_FORMULA_DISJUNCTION1" groupId="BUGGY_REDUCE_BOTTOM_IN_DISJUNCTION">
        <match>*X∨⊥∨*Y</match>
        <replace>⊥</replace>
        <tests>
            <assertApplicationResult>
                <input>X∨⊥</input>
                <expect>⊥</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>X∨⊥∨Y</input>
                <expect>⊥</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_BOTTOM_IN_FORMULA_CONJUNCTION1_PART" onlyPart="true">
        <match>*X∧⊥∧*Y</match>
        <replace>*X∧*Y</replace>
    </pattern>

    <sequential name="BUGGY_REDUCE_BOTTOM_IN_FORMULA_CONJUNCTION1" groupId="BUGGY_REDUCE_BOTTOM_IN_CONJUNCTION">
        <references>
            <reference name="BUGGY_CLEAN"/>
            <reference name="BUGGY_REDUCE_BOTTOM_IN_FORMULA_CONJUNCTION1_PART"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>X∧⊥</input>
                <expect>X</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>X∧⊥∧Y</input>
                <expect>X∧Y</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <pattern name="BUGGY_SWAP_PREMISE_AND_CONCLUSION">
        <match>$X → $Y</match>
        <replace>$Y → $X</replace>
        <tests>
            <assertApplicationResult>
                <input>X → Y</input>
                <expect>Y → X</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_MOVE_PARENTHESIS_IN_MULTILAYERED_IMPLICATION_FORWARDS" groupId="BUGGY_MOVE_PARENTHESIS_IN_MULTILAYERED_IMPLICATION">
        <match>$X → ($Y → $Z)</match>
        <replace>($X → $Y) → $Z</replace>
        <tests>
            <assertApplicationResult>
                <input>X → (Y → Z)</input>
                <expect>(X → Y) → Z</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_MOVE_PARENTHESIS_IN_MULTILAYERED_IMPLICATION_BACKWARDS" groupId="BUGGY_MOVE_PARENTHESIS_IN_MULTILAYERED_IMPLICATION">
        <match>($X → $Y) → $Z</match>
        <replace>$X → ($Y → $Z)</replace>
        <tests>
            <assertApplicationResult>
                <input>(X → Y) → Z</input>
                <expect>X → (Y → Z)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_IMPLICATIONAL_TAUTOLOGY">
        <match>$X → $X</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>X → X</input>
                <expect>X</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_EQUIVALENT_TAUTOLOGY">
        <match>$X ↔ $X</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>X ↔ X</input>
                <expect>X</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_EQUIVALENCE1" groupId="BUGGY_REMOVE_EQUIVALENCE">
        <match>$X ↔ $Y</match>
        <replace>($X∧$Y)∨¬($X∧$Y)</replace>
        <tests>
            <assertApplicationResult>
                <input>X ↔ Y</input>
                <expect>(X∧Y)∨¬(X∧Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_EQUIVALENCE2" groupId="BUGGY_REMOVE_EQUIVALENCE">
        <match>$X ↔ $Y</match>
        <replace>($X∧$Y)∨(¬$X∧$Y)</replace>
        <tests>
            <assertApplicationResult>
                <input>X ↔ Y</input>
                <expect>(X∧Y)∨(¬X∧Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_EQUIVALENCE3" groupId="BUGGY_REMOVE_EQUIVALENCE">
        <match>$X ↔ $Y</match>
        <replace>($X∧$Y)∨($X∧¬$Y)</replace>
        <tests>
            <assertApplicationResult>
                <input>X ↔ Y</input>
                <expect>(X∧Y)∨(X∧¬Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_EQUIVALENCE4" groupId="BUGGY_REMOVE_EQUIVALENCE">
        <match>$X ↔ $Y</match>
        <replace>($X∧$Y)∨($X∧$Y)</replace>
        <tests>
            <assertApplicationResult>
                <input>X ↔ Y</input>
                <expect>(X∧Y)∨(X∧Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_EQUIVALENCE5" groupId="BUGGY_REMOVE_EQUIVALENCE">
        <match>$X ↔ $Y</match>
        <replace>($X∧$Y)∨¬($X∨¬$Y)</replace>
        <tests>
            <assertApplicationResult>
                <input>X ↔ Y</input>
                <expect>(X∧Y)∨¬(X∨¬Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_EQUIVALENCE6" groupId="BUGGY_REMOVE_EQUIVALENCE">
        <match>$X ↔ $Y</match>
        <replace>($X∨$Y)∧(¬$X∨¬$Y)</replace>
        <tests>
            <assertApplicationResult>
                <input>X ↔ Y</input>
                <expect>(X∨Y)∧(¬X∨¬Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_EQUIVALENCE7" groupId="BUGGY_REMOVE_EQUIVALENCE">
        <match>$X ↔ $Y</match>
        <replace>($X∧$Y)∧(¬$X∧¬$Y)</replace>
        <tests>
            <assertApplicationResult>
                <input>X ↔ Y</input>
                <expect>(X∧Y)∧(¬X∧¬Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_EQUIVALENCE8" groupId="BUGGY_REMOVE_EQUIVALENCE">
        <match>$X ↔ $Y</match>
        <replace>($X∧$Y)∨(¬$X∨¬$Y)</replace>
        <tests>
            <assertApplicationResult>
                <input>X ↔ Y</input>
                <expect>(X∧Y)∨(¬X∨¬Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_EQUIVALENCE9" groupId="BUGGY_REMOVE_EQUIVALENCE">
        <match>$X ↔ $Y</match>
        <replace>¬$X∨$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X ↔ Y</input>
                <expect>¬X∨Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_IMPLICATION1" groupId="BUGGY_REMOVE_IMPLICATION">
        <match>$X → $Y</match>
        <replace>¬($X∨$Y)</replace>
        <tests>
            <assertApplicationResult>
                <input>X → Y</input>
                <expect>¬(X∨Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_IMPLICATION2" groupId="BUGGY_REMOVE_IMPLICATION">
        <match>$X → $Y</match>
        <replace>$X∨$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X → Y</input>
                <expect>X∨Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_IMPLICATION3" groupId="BUGGY_REMOVE_IMPLICATION">
        <match>$X → $Y</match>
        <replace>¬($X∧$Y)</replace>
        <tests>
            <assertApplicationResult>
                <input>X → Y</input>
                <expect>¬(X∧Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_IMPLICATION4" groupId="BUGGY_REMOVE_IMPLICATION">
        <match>$X → $Y</match>
        <replace>$X∨¬$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X → Y</input>
                <expect>X∨¬Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_IMPLICATION5" groupId="BUGGY_REMOVE_IMPLICATION">
        <match>$X → $Y</match>
        <replace>¬$X∧$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X → Y</input>
                <expect>¬X∧Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_IMPLICATION6" groupId="BUGGY_REMOVE_IMPLICATION">
        <match>$X → $Y</match>
        <replace>($X∧$Y)∨(¬$X∧¬$Y)</replace>
        <tests>
            <assertApplicationResult>
                <input>X → Y</input>
                <expect>(X∧Y)∨(¬X∧¬Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_IMPLICATION7" groupId="BUGGY_REMOVE_IMPLICATION">
        <match>($X∨$Y) → $Z</match>
        <replace>($X∨¬$Y)∨$Z</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∨Y) → Z</input>
                <expect>(X∨¬Y)∨Z</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_IMPLICATION8" groupId="BUGGY_REMOVE_IMPLICATION">
        <match>($X∧$Y) → $Z</match>
        <replace>($X∧¬$Y)∨$Z</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∧Y) → Z</input>
                <expect>(X∧¬Y)∨Z</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_IMPLICATION9" groupId="BUGGY_REMOVE_IMPLICATION">
        <match>($X → $Y) → $Z</match>
        <replace>($X → ¬$Y)∨$Z</replace>
        <tests>
            <assertApplicationResult>
                <input>(X → Y) → Z</input>
                <expect>(X → ¬Y)∨Z</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_IMPLICATION10" groupId="BUGGY_REMOVE_IMPLICATION">
        <match>($X ↔ $Y) → $Z</match>
        <replace>($X ↔ ¬$Y)∨$Z</replace>
        <tests>
            <assertApplicationResult>
                <input>(X ↔ Y) → Z</input>
                <expect>(X ↔ ¬Y)∨Z</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_IMPLICATION1_PART" onlyPart="true">
        <match>*A∧(¬$X)∧($Y)∧*Z</match>
        <replace>$X → (*A∧$Y∧*Z)</replace>
    </pattern>

    <sequential name="BUGGY_REDUCE_TO_IMPLICATION1" groupId="BUGGY_REDUCE_TO_IMPLICATION">
        <references>
            <reference name="BUGGY_REDUCE_TO_IMPLICATION1_PART"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>¬X∧Y</input>
                <expect>X → Y</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∧¬X∧Y∧Z</input>
                <expect>X → (A∧Y∧Z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∧X∧¬Y∧Z</input>
                <expect>Y → (A∧X∧Z)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <pattern name="BUGGY_REDUCE_TO_IMPLICATION2_PART" onlyPart="true">
        <match>*Z∨($X)∨(¬$Y)∨*A</match>
        <replace>(*Z∨$X∨*A) → $Y</replace>
    </pattern>

    <sequential name="BUGGY_REDUCE_TO_IMPLICATION2" groupId="BUGGY_REDUCE_TO_IMPLICATION">
        <references>
            <reference name="BUGGY_REDUCE_TO_IMPLICATION2_PART"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>X∨¬Y</input>
                <expect>X → Y</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>Z∨X∨¬Y∨A</input>
                <expect>(Z∨X∨A) → Y</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>Z∨¬X∨Y∨A</input>
                <expect>(Z∨Y∨A) → X</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <pattern name="BUGGY_REDUCE_TO_IMPLICATION3" groupId="BUGGY_REDUCE_TO_IMPLICATION">
        <match>($X)∧(¬$Y)</match>
        <replace>$Y → $X</replace>
        <tests>
            <assertApplicationResult>
                <input>X∧¬Y</input>
                <expect>Y → X</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_IMPLICATION4" groupId="BUGGY_REDUCE_TO_IMPLICATION">
        <match>¬$X∨$Y</match>
        <replace>$Y → $X</replace>
        <tests>
            <assertApplicationResult>
                <input>¬X∨Y</input>
                <expect>Y → X</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_IMPLICATION5_PART" onlyPart="true">
        <match>¬($X∨$Y∨*Z)</match>
        <replace>$X → ($Y∨*Z)</replace>
    </pattern>

    <sequential name="BUGGY_REDUCE_TO_IMPLICATION5" groupId="BUGGY_REDUCE_TO_IMPLICATION">
        <references>
            <reference name="BUGGY_REDUCE_TO_IMPLICATION5_PART"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>¬(X∨Y)</input>
                <expect>X → Y</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(X∨Y∨Z)</input>
                <expect>X → (Y∨Z)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <pattern name="BUGGY_PUSH_NEGATION1" groupId="BUGGY_PUSH_NEGATION">
        <match>¬($X∧*Z)</match>
        <replace>¬$X∨*Z</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(X∧Y)</input>
                <expect>¬X∨Y</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(X∧Y∧Z)</input>
                <expect>¬X∨Y∨Z</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_NEGATION2" groupId="BUGGY_PUSH_NEGATION">
        <match>¬($X∧$Y)</match>
        <replace>$X∨¬$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(X∧Y)</input>
                <expect>X∨¬Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_NEGATION3" groupId="BUGGY_PUSH_NEGATION">
        <match>¬($X∧*Y)</match>
        <replace>$X∨*Y</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(X∧Y)</input>
                <expect>X∨Y</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(X∧Y∧Z)</input>
                <expect>X∨Y∨Z</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_NEGATION4" groupId="BUGGY_PUSH_NEGATION">
        <match>¬($X∨*Y)</match>
        <replace>¬$X∧*Y</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(X∨Y)</input>
                <expect>¬X∧Y</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(X∨Y∨Z)</input>
                <expect>¬X∧Y∧Z</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_NEGATION5" groupId="BUGGY_PUSH_NEGATION">
        <match>¬($X∨$Y)</match>
        <replace>$X∧¬$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(X∨Y)</input>
                <expect>X∧¬Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_NEGATION6" groupId="BUGGY_PUSH_NEGATION">
        <match>¬($X∨*Y)</match>
        <replace>$X∧*Y</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(X∨Y)</input>
                <expect>X∧Y</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(X∨Y∨Z)</input>
                <expect>X∧Y∧Z</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_NEGATION_FROM_FRONT_OF_CONJUNCTION" onlyPart="true">
        <match>¬(*X∧...)</match>
        <replace>*X∧...</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(X∧Y)</input>
                <expect>X∧Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <childrenPattern name="BUGGY_NEGATE_LITERALS_IN_CONJUNCTION" onlyPart="true">
        <outer>($*∧...)</outer>
        <match>$X</match>
        <replace>¬$X</replace>
        <tests>
            <assertApplicationResult>
                <input>X∧Y</input>
                <expect>¬X∧¬Y</expect>
            </assertApplicationResult>
        </tests>
    </childrenPattern>

    <pattern name="BUGGY_SWAP_TO_DISJUNCTIONS_FROM_CONJUNCTION_AND_NEGATE" onlyPart="true">
        <match>*X∧...</match>
        <replace>¬(*X∨...)</replace>
        <tests>
            <assertApplicationResult>
                <input>¬X∧¬Y</input>
                <expect>¬(¬X∨¬Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <sequential name="BUGGY_PUSH_NEGATION7" groupId="BUGGY_PUSH_NEGATION">
        <references>
            <reference name="BUGGY_REMOVE_NEGATION_FROM_FRONT_OF_CONJUNCTION"/>
            <reference name="BUGGY_CLEAN"/>
            <reference name="BUGGY_NEGATE_LITERALS_IN_CONJUNCTION"/>
            <reference name="BUGGY_CLEAN"/>
            <reference name="BUGGY_SWAP_TO_DISJUNCTIONS_FROM_CONJUNCTION_AND_NEGATE"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>¬(X∧Y)</input>
                <expect>¬(¬X∨¬Y)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(X∧Y∧Z)</input>
                <expect>¬(¬X∨¬Y∨¬Z)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <pattern name="BUGGY_REMOVE_NEGATION_FROM_FRONT_OF_DISJUNCTION" onlyPart="true">
        <match>¬(*X∨...)</match>
        <replace>*X∨...</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(X∨Y)</input>
                <expect>X∨Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <childrenPattern name="BUGGY_NEGATE_LITERALS_IN_DISJUNCTION" onlyPart="true">
        <outer>($*∨...)</outer>
        <match>$X</match>
        <replace>¬$X</replace>
        <tests>
            <assertApplicationResult>
                <input>X∨Y</input>
                <expect>¬X∨¬Y</expect>
            </assertApplicationResult>
        </tests>
    </childrenPattern>

    <pattern name="BUGGY_SWAP_TO_CONJUNCTIONS_FROM_DISJUNCTION_AND_NEGATE" onlyPart="true">
        <match>*X∨...</match>
        <replace>¬(*X∧...)</replace>
        <tests>
            <assertApplicationResult>
                <input>¬X∨¬Y</input>
                <expect>¬(¬X∧¬Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <sequential name="BUGGY_PUSH_NEGATION8" groupId="BUGGY_PUSH_NEGATION">
        <references>
            <reference name="BUGGY_REMOVE_NEGATION_FROM_FRONT_OF_DISJUNCTION"/>
            <reference name="BUGGY_CLEAN"/>
            <reference name="BUGGY_NEGATE_LITERALS_IN_DISJUNCTION"/>
            <reference name="BUGGY_CLEAN"/>
            <reference name="BUGGY_SWAP_TO_CONJUNCTIONS_FROM_DISJUNCTION_AND_NEGATE"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>¬(X∨Y)</input>
                <expect>¬(¬X∧¬Y)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(X∨Y∨Z)</input>
                <expect>¬(¬X∧¬Y∧¬Z)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <sequential name="BUGGY_PUSH_NEGATION9" groupId="BUGGY_PUSH_NEGATION">
        <references>
            <reference name="BUGGY_REMOVE_NEGATION_FROM_FRONT_OF_CONJUNCTION"/>
            <reference name="BUGGY_NEGATE_LITERALS_IN_CONJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>¬(X∧Y)</input>
                <expect>¬X∧¬Y</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(X∧Y∧Z)</input>
                <expect>¬X∧¬Y∧¬Z</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <sequential name="BUGGY_PUSH_NEGATION10" groupId="BUGGY_PUSH_NEGATION">
        <references>
            <reference name="BUGGY_REMOVE_NEGATION_FROM_FRONT_OF_DISJUNCTION"/>
            <reference name="BUGGY_NEGATE_LITERALS_IN_DISJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>¬(X∨Y)</input>
                <expect>¬X∨¬Y</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(X∨Y∨Z)</input>
                <expect>¬X∨¬Y∨¬Z</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <pattern name="BUGGY_PUSH_NEGATION11" groupId="BUGGY_PUSH_NEGATION">
        <match>¬(¬($X∧$Y)∨*Z)</match>
        <replace>¬(¬$X∨¬$Y)∨*Z</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(¬(X∧Y)∨Z)</input>
                <expect>¬(¬X∨¬Y)∨Z</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(¬(X∧Y)∨Z∨A)</input>
                <expect>¬(¬X∨¬Y)∨Z∨A</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_NEGATION12" groupId="BUGGY_PUSH_NEGATION">
        <match>¬(¬($X∧$Y)∧*Z)</match>
        <replace>¬(¬$X∨¬$Y)∧*Z</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(¬(X∧Y)∧Z)</input>
                <expect>¬(¬X∨¬Y)∧Z</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(¬(X∧Y)∧Z∧A)</input>
                <expect>¬(¬X∨¬Y)∧Z∧A</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_NEGATION13" groupId="BUGGY_PUSH_NEGATION">
        <match>¬(¬($X∨$Y)∨*Z)</match>
        <replace>¬(¬$X∧¬$Y)∨*Z</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(¬(X∨Y)∨Z)</input>
                <expect>¬(¬X∧¬Y)∨Z</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(¬(X∨Y)∨Z∨A)</input>
                <expect>¬(¬X∧¬Y)∨Z∨A</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_NEGATION14" groupId="BUGGY_PUSH_NEGATION">
        <match>¬(¬($X∨$Y)∧*Z)</match>
        <replace>¬(¬$X∧¬$Y)∧*Z</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(¬(X∨Y)∧Z)</input>
                <expect>¬(¬X∧¬Y)∧Z</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(¬(X∨Y)∧Z∧A)</input>
                <expect>¬(¬X∧¬Y)∧Z∧A</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_NEGATION15" groupId="BUGGY_PUSH_NEGATION">
        <match>¬($X → $Y)</match>
        <replace>¬$X → ¬$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(X → Y)</input>
                <expect>¬X → ¬Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_NEGATION16" groupId="BUGGY_PUSH_NEGATION">
        <match>¬($X ↔ $Y)</match>
        <replace>¬($X∧$Y)∨(¬$X∧¬$Y)</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(X ↔ Y)</input>
                <expect>¬(X∧Y)∨(¬X∧¬Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <childrenPattern name="BUGGY_UNNEGATE_LITERALS_IN_CONJUNCTION" onlyPart="true">
        <outer>((¬$)*∧...)</outer>
        <match>¬$X</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>¬X∧¬Y</input>
                <expect>X∧Y</expect>
            </assertApplicationResult>
        </tests>
    </childrenPattern>

    <pattern name="BUGGY_NEGATE_CONJUNCTION" onlyPart="true">
        <match>*X∧...</match>
        <replace>¬(*X∧...)</replace>
        <tests>
            <assertApplicationResult>
                <input>X∧Y</input>
                <expect>¬(X∧Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <sequential name="BUGGY_PULL_NEGATION_CONJUNCTION" groupId="BUGGY_PULL_NEGATION">
        <references>
            <reference name="BUGGY_UNNEGATE_LITERALS_IN_CONJUNCTION"/>
            <reference name="BUGGY_NEGATE_CONJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>¬X∧¬Y</input>
                <expect>¬(X∧Y)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬X∧¬Y∧¬Z</input>
                <expect>¬(X∧Y∧Z)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <childrenPattern name="BUGGY_UNNEGATE_LITERALS_IN_DISJUNCTION" onlyPart="true">
        <outer>((¬$)*∨...)</outer>
        <match>¬$X</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>¬X∨¬Y</input>
                <expect>X∨Y</expect>
            </assertApplicationResult>
        </tests>
    </childrenPattern>

    <pattern name="BUGGY_NEGATE_DISJUNCTION" onlyPart="true">
        <match>*X∨...</match>
        <replace>¬(*X∨...)</replace>
        <tests>
            <assertApplicationResult>
                <input>X∨Y</input>
                <expect>¬(X∨Y)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <sequential name="BUGGY_PULL_NEGATION_DISJUNCTION" groupId="BUGGY_PULL_NEGATION">
        <references>
            <reference name="BUGGY_UNNEGATE_LITERALS_IN_DISJUNCTION"/>
            <reference name="BUGGY_NEGATE_DISJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>¬X∨¬Y</input>
                <expect>¬(X∨Y)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬X∨¬Y∨¬Z</input>
                <expect>¬(X∨Y∨Z)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <pattern name="BUGGY_REMOVE_PARENTHESIS1" groupId="BUGGY_REMOVE_PARENTHESIS">
        <match>¬($X∧$Y∧*Z)</match>
        <replace>¬$X∧$Y∧*Z</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(X∧Y)</input>
                <expect>¬X∧Y</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(X∧Y∧Z)</input>
                <expect>¬X∧Y∧Z</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_PARENTHESIS2" groupId="BUGGY_REMOVE_PARENTHESIS">
        <match>¬($X∨$Y∨*Z)</match>
        <replace>¬$X∨$Y∨*Z</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(X∨Y)</input>
                <expect>¬X∨Y</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(X∨Y∨Z)</input>
                <expect>¬X∨Y∨Z</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_PARENTHESIS3" groupId="BUGGY_REMOVE_PARENTHESIS">
        <match>¬(¬$X∧$Y∧*Z)</match>
        <replace>$X∧$Y∧*Z</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(¬X∧Y)</input>
                <expect>X∧Y</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>¬(¬X∧Y∧Z)</input>
                <expect>X∧Y∧Z</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_PARENTHESIS4" groupId="BUGGY_REMOVE_PARENTHESIS">
        <match>¬(¬$X → $Y)</match>
        <replace>$X → $Y</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(¬X → Y)</input>
                <expect>X → Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_PARENTHESIS5" groupId="BUGGY_REMOVE_PARENTHESIS">
        <match>¬(¬$X ↔ $Y)</match>
        <replace>$X ↔ $Y</replace>
        <tests>
            <assertApplicationResult>
                <input>¬(¬X ↔ Y)</input>
                <expect>X ↔ Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_MOVE_PARENTHESIS_INSTEAD_OF_DISTRIBUTION1" groupId="BUGGY_MOVE_PARENTHESIS_INSTEAD_OF_DISTRIBUTION">
        <match>*A∨$X∨($Y∧$Z∧*B)</match>
        <replace>(*A∨$X∨$Y)∧$Z∧*B</replace>
        <tests>
            <assertApplicationResult>
                <input>X∨(Y∧Z)</input>
                <expect>(X∨Y)∧Z</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∨X∨(Y∧Z∧B)</input>
                <expect>(A∨X∨Y)∧Z∧B</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_MOVE_PARENTHESIS_INSTEAD_OF_DISTRIBUTION2" groupId="BUGGY_MOVE_PARENTHESIS_INSTEAD_OF_DISTRIBUTION">
        <match>(*A∨$X∨$Y)∧$Z∧*B</match>
        <replace>*A∨$X∨($Y∧$Z∧*B)</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∨Y)∧Z</input>
                <expect>X∨(Y∧Z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>(A∨X∨Y)∧Z∧B</input>
                <expect>A∨X∨(Y∧Z∧B)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_MOVE_PARENTHESIS_INSTEAD_OF_DISTRIBUTION3" groupId="BUGGY_MOVE_PARENTHESIS_INSTEAD_OF_DISTRIBUTION">
        <match>(*A∧$X∧$Y)∨$Z∨*B</match>
        <replace>*A∧$X∧($Y∨$Z∨*B)</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∧Y)∨Z</input>
                <expect>X∧(Y∨Z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>(A∧X∧Y)∨Z∨B</input>
                <expect>A∧X∧(Y∨Z∨B)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_MOVE_PARENTHESIS_INSTEAD_OF_DISTRIBUTION4" groupId="BUGGY_MOVE_PARENTHESIS_INSTEAD_OF_DISTRIBUTION">
        <match>*A∧$X∧($Y∨$Z∨*B)</match>
        <replace>(*A∧$X∧$Y)∨$Z∨*B</replace>
        <tests>
            <assertApplicationResult>
                <input>X∧(Y∨Z)</input>
                <expect>(X∧Y)∨Z</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>A∧X∧(Y∨Z∨B)</input>
                <expect>(A∧X∧Y)∨Z∨B</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_SUBFORMULA1" groupId="BUGGY_REDUCE_TO_SUBFORMULA">
        <match>($X∨$Y)∧(($X∧$Y)∧*Z)</match>
        <replace>$X∨$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∨Y)∧((X∧Y)∧Z)</input>
                <expect>X∨Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_SUBFORMULA2" groupId="BUGGY_REDUCE_TO_SUBFORMULA">
        <match>($X∧$Y)∨(($X∨$Y)∧*Z)</match>
        <replace>$X∧$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∧Y)∨((X∨Y)∧Z)</input>
                <expect>X∧Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_SUBFORMULA3" groupId="BUGGY_REDUCE_TO_SUBFORMULA">
        <match>($X∨$Y)∧(($X∧$Y)∨*Z)</match>
        <replace>$X∨$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∨Y)∧((X∧Y)∨Z)</input>
                <expect>X∨Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_SUBFORMULA4" groupId="BUGGY_REDUCE_TO_SUBFORMULA">
        <match>($X∧$Y)∨(($X∨$Y)∨*Z)</match>
        <replace>$X∧$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∧Y)∨((X∨Y)∨Z)</input>
                <expect>X∧Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_SUBFORMULA5" groupId="BUGGY_REDUCE_TO_SUBFORMULA">
        <match>$X∨($X∧$Y)</match>
        <replace>$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X∨(X∧Y)</input>
                <expect>Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_SUBFORMULA6" groupId="BUGGY_REDUCE_TO_SUBFORMULA">
        <match>$X∨($Y∧$X)</match>
        <replace>$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X∨(Y∧X)</input>
                <expect>Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_SUBFORMULA7" groupId="BUGGY_REDUCE_TO_SUBFORMULA">
        <match>($X∧$Y)∨$X</match>
        <replace>$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∧Y)∨X</input>
                <expect>Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_SUBFORMULA8" groupId="BUGGY_REDUCE_TO_SUBFORMULA">
        <match>($Y∧$X)∨$X</match>
        <replace>$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>(Y∧X)∨X</input>
                <expect>Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_SUBFORMULA9" groupId="BUGGY_REDUCE_TO_SUBFORMULA">
        <match>$X∧($X∨$Y)</match>
        <replace>$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X∧(X∨Y)</input>
                <expect>Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_SUBFORMULA10" groupId="BUGGY_REDUCE_TO_SUBFORMULA">
        <match>$X∧($Y∨$X)</match>
        <replace>$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X∧(Y∨X)</input>
                <expect>Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_SUBFORMULA11" groupId="BUGGY_REDUCE_TO_SUBFORMULA">
        <match>($X∨$Y)∧$X</match>
        <replace>$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∨Y)∧X</input>
                <expect>Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REDUCE_TO_SUBFORMULA12" groupId="BUGGY_REDUCE_TO_SUBFORMULA">
        <match>($Y∨$X)∧$X</match>
        <replace>$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>(Y∨X)∧X</input>
                <expect>Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <childrenPattern name="BUGGY_DISTRIBUTE_INTO_RIGHT_DISJUNCTION" onlyPart="true">
        <pathChild>1</pathChild>
        <outer> $X ∧ ($*∨...)</outer>
        <match>$Y</match>
        <replace>$X∧$Y</replace>
    </childrenPattern>

    <pattern name="BUGGY_REMOVE_CONJUNCTION_PREFIX_AND_SWAP_DISJUNCTION_TO_CONJUNCTION" onlyPart="true">
        <match>$∧(*X∨...)</match>
        <replace>(*X∧...)</replace>
    </pattern>

    <sequential name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET1" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_CLEAN"/>
            <reference name="BUGGY_DISTRIBUTE_INTO_RIGHT_DISJUNCTION"/>
            <reference name="BUGGY_REMOVE_CONJUNCTION_PREFIX_AND_SWAP_DISJUNCTION_TO_CONJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>X∧(Y∨Z)</input>
                <expect>(X∧Y)∧(X∧Z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>X∧(Y∨Z∨A)</input>
                <expect>(X∧Y)∧(X∧Z)∧(X∧A)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <childrenPattern name="BUGGY_DISTRIBUTE_INTO_LEFT_DISJUNCTION" onlyPart="true">
        <pathChild>0</pathChild>
        <outer> ($*∨...) ∧ $X</outer>
        <match>$Y</match>
        <replace>$Y∧$X</replace>
    </childrenPattern>

    <pattern name="BUGGY_REMOVE_CONJUNCTION_APPENDIX_AND_SWAP_DISJUNCTION_TO_CONJUNCTION" onlyPart="true">
        <match>(*X∨...)∧$</match>
        <replace>(*X∧...)</replace>
    </pattern>

    <sequential name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET2" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_CLEAN"/>
            <reference name="BUGGY_DISTRIBUTE_INTO_LEFT_DISJUNCTION"/>
            <reference name="BUGGY_REMOVE_CONJUNCTION_APPENDIX_AND_SWAP_DISJUNCTION_TO_CONJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(X∨Y)∧Z</input>
                <expect>(X∧Z)∧(Y∧Z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>(X∨Y∨A)∧Z</input>
                <expect>(X∧Z)∧(Y∧Z)∧(A∧Z)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <childrenPattern name="BUGGY_DISTRIBUTE_INTO_LEFT_DISJUNCTION_WITH_INNER_DISJUNCTION" onlyPart="true">
        <pathChild>1</pathChild>
        <outer> $X∧($*∨...)</outer>
        <match>$Y</match>
        <replace>$X∨$Y</replace>
    </childrenPattern>

    <sequential name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET3" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_CLEAN"/>
            <reference name="BUGGY_DISTRIBUTE_INTO_LEFT_DISJUNCTION_WITH_INNER_DISJUNCTION"/>
            <reference name="BUGGY_REMOVE_CONJUNCTION_PREFIX_AND_SWAP_DISJUNCTION_TO_CONJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>X∧(Y∨Z)</input>
                <expect>(X∨Y)∧(X∨Z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>X∧(Y∨Z∨A)</input>
                <expect>(X∨Y)∧(X∨Z)∧(X∨A)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <childrenPattern name="BUGGY_DISTRIBUTE_INTO_RIGHT_DISJUNCTION_WITH_INNER_DISJUNCTION" onlyPart="true">
        <pathChild>0</pathChild>
        <outer> ($*∨...)∧$X</outer>
        <match>$Y</match>
        <replace>$Y∨$X</replace>
    </childrenPattern>

    <sequential name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET4" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_CLEAN"/>
            <reference name="BUGGY_DISTRIBUTE_INTO_RIGHT_DISJUNCTION_WITH_INNER_DISJUNCTION"/>
            <reference name="BUGGY_REMOVE_CONJUNCTION_APPENDIX_AND_SWAP_DISJUNCTION_TO_CONJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(X∨Y)∧Z</input>
                <expect>(X∨Z)∧(Y∨Z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>(X∨Y∨A)∧Z</input>
                <expect>(X∨Z)∧(Y∨Z)∧(A∨Z)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <childrenPattern name="BUGGY_DISTRIBUTE_INTO_LEFT_CONJUNCTION" onlyPart="true">
        <pathChild>1</pathChild>
        <outer> $X∨($*∧...) </outer>
        <match>$Y</match>
        <replace>$X∨$Y</replace>
    </childrenPattern>

    <pattern name="BUGGY_REMOVE_DISJUNCTION_PREFIX_AND_SWAP_CONJUNCTION_TO_DISJUNCTION" onlyPart="true">
        <match>$∨(*X∧...)</match>
        <replace>(*X∨...)</replace>
    </pattern>

    <sequential name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET5" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_CLEAN"/>
            <reference name="BUGGY_DISTRIBUTE_INTO_LEFT_CONJUNCTION"/>
            <reference name="BUGGY_REMOVE_DISJUNCTION_PREFIX_AND_SWAP_CONJUNCTION_TO_DISJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>X∨(Y∧Z)</input>
                <expect>(X∨Y)∨(X∨Z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>X∨(Y∧Z∧A)</input>
                <expect>(X∨Y)∨(X∨Z)∨(X∨A)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <childrenPattern name="BUGGY_DISTRIBUTE_INTO_RIGHT_CONJUNCTION" onlyPart="true">
        <pathChild>0</pathChild>
        <outer> ($*∧...)∨$X </outer>
        <match>$Y</match>
        <replace>$Y∨$X</replace>
    </childrenPattern>

    <pattern name="BUGGY_REMOVE_DISJUNCTION_APPENDIX_AND_SWAP_CONJUNCTION_TO_DISJUNCTION" onlyPart="true">
        <match>(*X∧...)∨$</match>
        <replace>(*X∨...)</replace>
    </pattern>

    <sequential name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET6" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_CLEAN"/>
            <reference name="BUGGY_DISTRIBUTE_INTO_RIGHT_CONJUNCTION"/>
            <reference name="BUGGY_REMOVE_DISJUNCTION_APPENDIX_AND_SWAP_CONJUNCTION_TO_DISJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(X∧Y)∨Z</input>
                <expect>(X∨Z)∨(Y∨Z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>(X∧Y∧A)∨Z</input>
                <expect>(X∨Z)∨(Y∨Z)∨(A∨Z)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <childrenPattern name="BUGGY_DISTRIBUTE_INTO_RIGHT_CONJUNCTION_WITH_INNER_CONJUNCTION" onlyPart="true">
        <pathChild>1</pathChild>
        <outer> $X∨($*∧...) </outer>
        <match>$Y</match>
        <replace>$X∧$Y</replace>
    </childrenPattern>

    <sequential name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET7" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_CLEAN"/>
            <reference name="BUGGY_DISTRIBUTE_INTO_RIGHT_CONJUNCTION_WITH_INNER_CONJUNCTION"/>
            <reference name="BUGGY_REMOVE_DISJUNCTION_PREFIX_AND_SWAP_CONJUNCTION_TO_DISJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>X∨(Y∧Z)</input>
                <expect>(X∧Y)∨(X∧Z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>X∨(Y∧Z∧A)</input>
                <expect>(X∧Y)∨(X∧Z)∨(X∧A)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <childrenPattern name="BUGGY_DISTRIBUTE_INTO_LEFT_CONJUNCTION_WITH_INNER_CONJUNCTION" onlyPart="true">
        <pathChild>0</pathChild>
        <outer> ($*∧...)∨$X </outer>
        <match>$Y</match>
        <replace>$Y∧$X</replace>
    </childrenPattern>

    <sequential name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET8" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_CLEAN"/>
            <reference name="BUGGY_DISTRIBUTE_INTO_LEFT_CONJUNCTION_WITH_INNER_CONJUNCTION"/>
            <reference name="BUGGY_REMOVE_DISJUNCTION_APPENDIX_AND_SWAP_CONJUNCTION_TO_DISJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(X∧Y)∨Z</input>
                <expect>(X∧Z)∨(Y∧Z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>(X∧Y∧A)∨Z</input>
                <expect>(X∧Z)∨(Y∧Z)∨(A∧Z)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>


    <pattern name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET13" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <match>¬$X∧($Y∨$Z)</match>
        <replace>(¬$X∧$Y)∨($X∧$Z)</replace>
        <tests>
            <assertApplicationResult>
                <input>¬X∧(Y∨Z)</input>
                <expect>(¬X∧Y)∨(X∧Z)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET14" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <match>¬$X∧($Y∨$Z)</match>
        <replace>($X∧$Y)∨(¬$X∧$Z)</replace>
        <tests>
            <assertApplicationResult>
                <input>¬X∧(Y∨Z)</input>
                <expect>(X∧Y)∨(¬X∧Z)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET15" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <match>($X∨$Y)∧¬$Z</match>
        <replace>($X∧¬$Z)∨($Y∧$Z)</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∨Y)∧¬Z</input>
                <expect>(X∧¬Z)∨(Y∧Z)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET16" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <match>($X∨$Y)∧¬$Z</match>
        <replace>($X∧$Z)∨($Y∧¬$Z)</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∨Y)∧¬Z</input>
                <expect>(X∧Z)∨(Y∧¬Z)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET17" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <match>¬$X∨($Y∧$Z)</match>
        <replace>(¬$X∨$Y)∧($X∨$Z)</replace>
        <tests>
            <assertApplicationResult>
                <input>¬X∨(Y∧Z)</input>
                <expect>(¬X∨Y)∧(X∨Z)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET18" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <match>¬$X∨($Y∧$Z)</match>
        <replace>($X∨$Y)∧(¬$X∨$Z)</replace>
        <tests>
            <assertApplicationResult>
                <input>¬X∨(Y∧Z)</input>
                <expect>(X∨Y)∧(¬X∨Z)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET19" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <match>($X∧$Y)∨¬$Z</match>
        <replace>($X∨¬$Z)∧($Y∨$Z)</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∧Y)∨¬Z</input>
                <expect>(X∨¬Z)∧(Y∨Z)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET20" groupId="BUGGY_PUSH_DISTRIBUTION_TO_WRONG_TARGET">
        <match>($X∧$Y)∨¬$Z</match>
        <replace>($X∨$Z)∧($Y∨¬$Z)</replace>
        <tests>
            <assertApplicationResult>
                <input>(X∧Y)∨¬Z</input>
                <expect>(X∨Z)∧(Y∨¬Z)</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_SWAP_CONJUNCTION_TO_DISJUNCTION" onlyPart="true">
        <match>(*X∧...)</match>
        <replace>(*X∨...)</replace>
    </pattern>

    <invertible name="BUGGY_ISOLATE_DISTRIBUTED_DISJUNCTIONS_FROM_LEFT" onlyPart="true">
        <match>X@(($∧$Y)*∨...)</match>
        <replace>$X∧$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>(x∧z)∨(y∧z)</input>
                <expect>((x∧z)∨(y∧z))∧z</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <childrenPattern name="BUGGY_UNDISTRIBUTE_INTO_LEFT_CONJUNCTION" onlyPart="true">
        <pathChild>0</pathChild>
        <outer>(($∧$)*∨...) ∧ $Y</outer>
        <match>$X∧$Y</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>((x∧z)∨(y∧z))∧z</input>
                <expect>(x∨y)∧z</expect>
            </assertApplicationResult>
        </tests>
    </childrenPattern>

    <sequential name="BUGGY_UNDISTRIBUTE_LEFT_CONJUNCTION_OVER_OTHER" groupId="BUGGY_PULL_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_SWAP_CONJUNCTION_TO_DISJUNCTION"/>
            <reference name="BUGGY_ISOLATE_DISTRIBUTED_DISJUNCTIONS_FROM_LEFT"/>
            <reference name="BUGGY_UNDISTRIBUTE_INTO_LEFT_CONJUNCTION"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(x∧z)∧(y∧z)</input>
                <expect>(x∨y)∧z</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>(x∧(x↔y))∧(y∧(x↔y))∧(z∧(x↔y))</input>
                <expect>(x∨y∨z)∧(x↔y)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>


    <invertible name="BUGGY_ISOLATE_DISTRIBUTED_DISJUNCTIONS_FROM_RIGHT" onlyPart="true">
        <match>Y@(($X∧$)*∨...)</match>
        <replace>$X∧$Y</replace>
    </invertible>

    <childrenPattern name="BUGGY_UNDISTRIBUTE_INTO_RIGHT_CONJUNCTION" onlyPart="true">
        <pathChild>1</pathChild>
        <outer>$X ∧ (($∧$)*∨...)</outer>
        <match>$X∧$Y</match>
        <replace>$Y</replace>
    </childrenPattern>

    <sequential name="BUGGY_UNDISTRIBUTE_RIGHT_CONJUNCTION_OVER_OTHER" groupId="BUGGY_PULL_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_SWAP_CONJUNCTION_TO_DISJUNCTION"/>
            <reference name="BUGGY_ISOLATE_DISTRIBUTED_DISJUNCTIONS_FROM_RIGHT"/>
            <reference name="BUGGY_UNDISTRIBUTE_INTO_RIGHT_CONJUNCTION"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(x∧y)∧(x∧z)</input>
                <expect>x∧(y∨z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>((x↔y)∧x)∧((x↔y)∧y)∧((x↔y)∧z)</input>
                <expect>(x↔y)∧(x∨y∨z)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>



    <pattern name="BUGGY_SWAP_DISJUNCTION_TO_CONJUNCTION" onlyPart="true">
        <match>(*X∨...)</match>
        <replace>(*X∧...)</replace>
    </pattern>

    <invertible name="BUGGY_ISOLATE_DISTRIBUTED_CONJUNCTIONS_FROM_LEFT" onlyPart="true">
        <match>X@(($∨$Y)*∧...)</match>
        <replace>$X∨$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>(x∨z)∧(y∨z)</input>
                <expect>((x∨z)∧(y∨z))∨z</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <childrenPattern name="BUGGY_UNDISTRIBUTE_INTO_LEFT_DISJUNCTION" onlyPart="true">
        <pathChild>0</pathChild>
        <outer>(($∨$)*∧...) ∨ $Y</outer>
        <match>$X∨$Y</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>((x∨z)∧(y∨z))∨z</input>
                <expect>(x∧y)∨z</expect>
            </assertApplicationResult>
        </tests>
    </childrenPattern>

    <sequential name="BUGGY_UNDISTRIBUTE_LEFT_DISJUNCTION_OVER_OTHER" groupId="BUGGY_PULL_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_SWAP_DISJUNCTION_TO_CONJUNCTION"/>
            <reference name="BUGGY_ISOLATE_DISTRIBUTED_CONJUNCTIONS_FROM_LEFT"/>
            <reference name="BUGGY_UNDISTRIBUTE_INTO_LEFT_DISJUNCTION"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(x∨z)∨(y∨z)</input>
                <expect>(x∧y)∨z</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>(x∨(x↔y))∨(y∨(x↔y))∨(z∨(x↔y))</input>
                <expect>(x∧y∧z)∨(x↔y)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>


    <invertible name="BUGGY_ISOLATE_DISTRIBUTED_CONJUNCTIONS_FROM_RIGHT" onlyPart="true">
        <match>Y@(($X∨$)*∧...)</match>
        <replace>$X∨$Y</replace>
    </invertible>

    <childrenPattern name="BUGGY_UNDISTRIBUTE_INTO_RIGHT_DISJUNCTION" onlyPart="true">
        <pathChild>1</pathChild>
        <outer>$X ∨ (($∨$)*∧...)</outer>
        <match>$X∨$Y</match>
        <replace>$Y</replace>
    </childrenPattern>

    <sequential name="BUGGY_UNDISTRIBUTE_RIGHT_DISJUNCTION_OVER_OTHER" groupId="BUGGY_PULL_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_SWAP_DISJUNCTION_TO_CONJUNCTION"/>
            <reference name="BUGGY_ISOLATE_DISTRIBUTED_CONJUNCTIONS_FROM_RIGHT"/>
            <reference name="BUGGY_UNDISTRIBUTE_INTO_RIGHT_DISJUNCTION"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(x∨y)∨(x∨z)</input>
                <expect>x∨(y∧z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>((x↔y)∨x)∨((x↔y)∨y)∨((x↔y)∨z)</input>
                <expect>(x↔y)∨(x∧y∧z)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>


    <invertible name="BUGGY_ISOLATE_DISTRIBUTED_DISJUNCTIONS_FROM_LEFT_WITH_CONJUNCTION" onlyPart="true">
        <match>X@(($∨$Y)*∨...)</match>
        <replace>$X∧$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>(x∨z)∨(y∨z)</input>
                <expect>((x∨z)∨(y∨z))∧z</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <childrenPattern name="BUGGY_UNDISTRIBUTE_INTO_LEFT_CONJUNCTION_WITH_CONJUNCTION" onlyPart="true">
        <pathChild>0</pathChild>
        <outer>(($∨$)*∨...) ∧ $Y</outer>
        <match>$X∨$Y</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>((x∨z)∨(y∨z))∧z</input>
                <expect>(x∨y)∧z</expect>
            </assertApplicationResult>
        </tests>
    </childrenPattern>

    <sequential name="BUGGY_UNDISTRIBUTE_LEFT_CONJUNCTION_OVER_DISJUNCTION" groupId="BUGGY_PULL_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_SWAP_CONJUNCTION_TO_DISJUNCTION"/>
            <reference name="BUGGY_ISOLATE_DISTRIBUTED_DISJUNCTIONS_FROM_LEFT_WITH_CONJUNCTION"/>
            <reference name="BUGGY_UNDISTRIBUTE_INTO_LEFT_CONJUNCTION_WITH_CONJUNCTION"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(x∨z)∧(y∨z)</input>
                <expect>(x∨y)∧z</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>(x∨(x↔y))∧(y∨(x↔y))∧(z∨(x↔y))</input>
                <expect>(x∨y∨z)∧(x↔y)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>


    <invertible name="BUGGY_ISOLATE_DISTRIBUTED_DISJUNCTIONS_FROM_RIGHT_WITH_CONJUNCTION" onlyPart="true">
        <match>Y@(($X∨$)*∨...)</match>
        <replace>$X∧$Y</replace>
    </invertible>

    <childrenPattern name="BUGGY_UNDISTRIBUTE_INTO_RIGHT_CONJUNCTION_WITH_CONJUNCTION" onlyPart="true">
        <pathChild>1</pathChild>
        <outer>$X ∧ (($∨$)*∨...)</outer>
        <match>$X∨$Y</match>
        <replace>$Y</replace>
    </childrenPattern>

    <sequential name="BUGGY_UNDISTRIBUTE_RIGHT_CONJUNCTION_OVER_DISJUNCTION" groupId="BUGGY_PULL_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_SWAP_CONJUNCTION_TO_DISJUNCTION"/>
            <reference name="BUGGY_ISOLATE_DISTRIBUTED_DISJUNCTIONS_FROM_RIGHT_WITH_CONJUNCTION"/>
            <reference name="BUGGY_UNDISTRIBUTE_INTO_RIGHT_CONJUNCTION_WITH_CONJUNCTION"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(x∨y)∧(x∨z)</input>
                <expect>x∧(y∨z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>((x↔y)∨x)∧((x↔y)∨y)∧((x↔y)∨z)</input>
                <expect>(x↔y)∧(x∨y∨z)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>


    <invertible name="BUGGY_ISOLATE_DISTRIBUTED_CONJUNCTIONS_FROM_LEFT_WITH_DISJUNCTION" onlyPart="true">
        <match>X@(($∧$Y)*∧...)</match>
        <replace>$X∨$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>(x∧z)∧(y∧z)</input>
                <expect>((x∧z)∧(y∧z))∨z</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <childrenPattern name="BUGGY_UNDISTRIBUTE_INTO_LEFT_DISJUNCTION_WITH_DISJUNCTION" onlyPart="true">
        <pathChild>0</pathChild>
        <outer>(($∧$)*∧...) ∨ $Y</outer>
        <match>$X∧$Y</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>((x∧z)∧(y∧z))∨z</input>
                <expect>(x∧y)∨z</expect>
            </assertApplicationResult>
        </tests>
    </childrenPattern>

    <sequential name="BUGGY_UNDISTRIBUTE_LEFT_DISJUNCTION_OVER_CONJUNCTION" groupId="BUGGY_PULL_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_SWAP_DISJUNCTION_TO_CONJUNCTION"/>
            <reference name="BUGGY_ISOLATE_DISTRIBUTED_CONJUNCTIONS_FROM_LEFT_WITH_DISJUNCTION"/>
            <reference name="BUGGY_UNDISTRIBUTE_INTO_LEFT_DISJUNCTION_WITH_DISJUNCTION"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(x∧z)∨(y∧z)</input>
                <expect>(x∧y)∨z</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>(x∧(x↔y))∨(y∧(x↔y))∨(z∧(x↔y))</input>
                <expect>(x∧y∧z)∨(x↔y)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>


    <invertible name="BUGGY_ISOLATE_DISTRIBUTED_CONJUNCTIONS_FROM_RIGHT_WITH_DISJUNCTION" onlyPart="true">
        <match>Y@(($X∧$)*∧...)</match>
        <replace>$X∨$Y</replace>
    </invertible>

    <childrenPattern name="BUGGY_UNDISTRIBUTE_INTO_RIGHT_DISJUNCTION_WITH_DISJUNCTION" onlyPart="true">
        <pathChild>1</pathChild>
        <outer>$X ∨ (($∧$)*∧...)</outer>
        <match>$X∧$Y</match>
        <replace>$Y</replace>
    </childrenPattern>

    <sequential name="BUGGY_UNDISTRIBUTE_RIGHT_DISJUNCTION_OVER_CONJUNCTION" groupId="BUGGY_PULL_DISTRIBUTION_TO_WRONG_TARGET">
        <references>
            <reference name="BUGGY_SWAP_DISJUNCTION_TO_CONJUNCTION"/>
            <reference name="BUGGY_ISOLATE_DISTRIBUTED_CONJUNCTIONS_FROM_RIGHT_WITH_DISJUNCTION"/>
            <reference name="BUGGY_UNDISTRIBUTE_INTO_RIGHT_DISJUNCTION_WITH_DISJUNCTION"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(x∧y)∨(x∧z)</input>
                <expect>x∨(y∧z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>((x↔y)∧x)∨((x↔y)∧y)∨((x↔y)∧z)</input>
                <expect>(x↔y)∨(x∧y∧z)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>


    <invertible name="BUGGY_MOVE_PARENTHESIS1" groupId="BUGGY_MOVE_PARENTHESIS">
        <match>(¬$X)∧*Y</match>
        <replace>¬($X∧*Y)</replace>
        <tests>
            <assertApplicationResult>
                <input>(¬X)∧Y</input>
                <expect>¬(X∧Y)</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_MOVE_PARENTHESIS2" groupId="BUGGY_MOVE_PARENTHESIS">
        <match>(¬$X)∨*Y</match>
        <replace>¬($X∨*Y)</replace>
        <tests>
            <assertApplicationResult>
                <input>(¬X)∨Y</input>
                <expect>¬(X∨Y)</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_MOVE_PARENTHESIS3_PART" onlyPart="true">
        <match>(¬$X)∨($Y)∨*Z</match>
        <replace>¬($X→($Y∨*Z))</replace>
    </invertible>

    <sequential name="BUGGY_MOVE_PARENTHESIS3" groupId="BUGGY_MOVE_PARENTHESIS">
        <references>
            <reference name="BUGGY_MOVE_PARENTHESIS3_PART"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(¬X)∨Y</input>
                <expect>¬(X→Y)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>(¬X)∨Y∨Z</input>
                <expect>¬(X→(Y∨Z))</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <invertible name="BUGGY_MOVE_PARENTHESIS4" groupId="BUGGY_MOVE_PARENTHESIS">
        <match>*X∧($Y→$Z)</match>
        <replace>(*X∧$Y)→$Z</replace>
        <tests>
            <assertApplicationResult>
                <input>X∧(Y→Z)</input>
                <expect>(X∧Y)→Z</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_MOVE_PARENTHESIS5" groupId="BUGGY_MOVE_PARENTHESIS">
        <match>($X→$Y)∧*Z</match>
        <replace>$X→($Y∧*Z)</replace>
        <tests>
            <assertApplicationResult>
                <input>(X→Y)∧Z</input>
                <expect>X→(Y∧Z)</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_MOVE_PARENTHESIS6" groupId="BUGGY_MOVE_PARENTHESIS">
        <match>*X∨($Y→$Z)</match>
        <replace>(*X∨$Y)→$Z</replace>
        <tests>
            <assertApplicationResult>
                <input>X∨(Y→Z)</input>
                <expect>(X∨Y)→Z</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_MOVE_PARENTHESIS7" groupId="BUGGY_MOVE_PARENTHESIS">
        <match>($X→$Y)∨*Z</match>
        <replace>$X→($Y∨*Z)</replace>
        <tests>
            <assertApplicationResult>
                <input>(X→Y)∨Z</input>
                <expect>X→(Y∨Z)</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_MOVE_PARENTHESIS8" groupId="BUGGY_MOVE_PARENTHESIS">
        <match>*X∧($Y↔$Z)</match>
        <replace>(*X∧$Y)↔$Z</replace>
        <tests>
            <assertApplicationResult>
                <input>X∧(Y↔Z)</input>
                <expect>(X∧Y)↔Z</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_MOVE_PARENTHESIS9" groupId="BUGGY_MOVE_PARENTHESIS">
        <match>($X↔$Y)∧*Z</match>
        <replace>$X↔($Y∧*Z)</replace>
        <tests>
            <assertApplicationResult>
                <input>(X↔Y)∧Z</input>
                <expect>X↔(Y∧Z)</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_MOVE_PARENTHESIS10" groupId="BUGGY_MOVE_PARENTHESIS">
        <match>*X∨($Y↔$Z)</match>
        <replace>(*X∨$Y)↔$Z</replace>
        <tests>
            <assertApplicationResult>
                <input>X∨(Y↔Z)</input>
                <expect>(X∨Y)↔Z</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_MOVE_PARENTHESIS11" groupId="BUGGY_MOVE_PARENTHESIS">
        <match>($X↔$Y)∨*Z</match>
        <replace>$X↔($Y∨*Z)</replace>
        <tests>
            <assertApplicationResult>
                <input>(X↔Y)∨Z</input>
                <expect>X↔(Y∨Z)</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_REMOVE_NEGATION">
        <match>¬$X</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>¬X</input>
                <expect>X</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_ADD_NEGATION">
        <match>$X</match>
        <replace>¬$X</replace>
        <tests>
            <assertApplicationResult>
                <input>X</input>
                <expect>¬X</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <pattern name="BUGGY_REMOVE_SUBFORMULA1_PART" onlyPart="true">
        <!--removes last subformula-->
        <match>($U∧*X∧$Y)</match>
        <replace>($U∧*X)</replace>
    </pattern>

    <sequential name="BUGGY_REMOVE_SUBFORMULA1" groupId="BUGGY_REMOVE_SUBFORMULA">
        <references>
            <reference name="BUGGY_REMOVE_SUBFORMULA1_PART"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(U∧X∧Y∧Z)</input>
                <expect>(U∧X∧Y)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>X∧Y</input>
                <expect>X</expect>
            </assertApplicationResult>
        </tests>
    </sequential>


    <pattern name="BUGGY_REMOVE_SUBFORMULA2_PART" onlyPart="true">
        <!--removes first subformula-->
        <match>($X∧$Y∧*Z)</match>
        <replace>($Y∧*Z)</replace>
    </pattern>

    <sequential name="BUGGY_REMOVE_SUBFORMULA2" groupId="BUGGY_REMOVE_SUBFORMULA">
        <references>
            <reference name="BUGGY_REMOVE_SUBFORMULA2_PART"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(U∧X∧Y∧Z)</input>
                <expect>(X∧Y∧Z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>X∧Y</input>
                <expect>Y</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <pattern name="BUGGY_REMOVE_SUBFORMULA3_PART" onlyPart="true">
        <!-- removes last subformula -->
        <match>($U∨*X∨$Y)</match>
        <replace>($U∨*X)</replace>
    </pattern>

    <sequential name="BUGGY_REMOVE_SUBFORMULA3" groupId="BUGGY_REMOVE_SUBFORMULA">
        <references>
            <reference name="BUGGY_REMOVE_SUBFORMULA3_PART"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(U∨X∨Y∨Z)</input>
                <expect>(U∨X∨Y)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>X∨Y</input>
                <expect>X</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <pattern name="BUGGY_REMOVE_SUBFORMULA4_PART" onlyPart="true">
        <!-- removes first subformula -->
        <match>($X∨$Y∨*Z)</match>
        <replace>($Y∨*Z)</replace>
    </pattern>

    <sequential name="BUGGY_REMOVE_SUBFORMULA4" groupId="BUGGY_REMOVE_SUBFORMULA">
        <references>
            <reference name="BUGGY_REMOVE_SUBFORMULA4_PART"/>
            <reference name="BUGGY_CLEAN"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>(U∨X∨Y∨Z)</input>
                <expect>(X∨Y∨Z)</expect>
            </assertApplicationResult>
            <assertApplicationResult>
                <input>X∨Y</input>
                <expect>Y</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <pattern name="BUGGY_REMOVE_SUBFORMULA5" groupId="BUGGY_REMOVE_SUBFORMULA">
        <match>($X→$Y)</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>(X→Y)</input>
                <expect>X</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_SUBFORMULA6" groupId="BUGGY_REMOVE_SUBFORMULA">
        <match>($X↔$Y)</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>(X↔Y)</input>
                <expect>X</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_SUBFORMULA7" groupId="BUGGY_REMOVE_SUBFORMULA">
        <match>($X→$Y)</match>
        <replace>$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>(X→Y)</input>
                <expect>Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <pattern name="BUGGY_REMOVE_SUBFORMULA8" groupId="BUGGY_REMOVE_SUBFORMULA">
        <match>($X↔$Y)</match>
        <replace>$Y</replace>
        <tests>
            <assertApplicationResult>
                <input>(X↔Y)</input>
                <expect>Y</expect>
            </assertApplicationResult>
        </tests>
    </pattern>

    <patternNewFormula name="BUGGY_ADD_SUBFORMULA1" groupId="BUGGY_ADD_SUBFORMULA">
        <match>*X∧...</match>
        <replace>*X∧$Y</replace>
        <newFormula>Y</newFormula>
    </patternNewFormula>

    <patternNewFormula name="BUGGY_ADD_SUBFORMULA2" groupId="BUGGY_ADD_SUBFORMULA">
        <match>*X∨...</match>
        <replace>*X∨$Y</replace>
        <newFormula>Y</newFormula>
    </patternNewFormula>

    <patternNewFormula name="BUGGY_ADD_SUBFORMULA3" groupId="BUGGY_ADD_SUBFORMULA">
        <match>$X</match>
        <replace>$X→$Y</replace>
        <newFormula>Y</newFormula>
    </patternNewFormula>

    <patternNewFormula name="BUGGY_ADD_SUBFORMULA4" groupId="BUGGY_ADD_SUBFORMULA">
        <match>$X</match>
        <replace>$X↔$Y</replace>
        <newFormula>Y</newFormula>
    </patternNewFormula>

    <patternNewFormula name="BUGGY_ADD_SUBFORMULA5" groupId="BUGGY_ADD_SUBFORMULA">
        <match>*X∧...</match>
        <replace>$Y∧*X</replace>
        <newFormula>Y</newFormula>
    </patternNewFormula>

    <patternNewFormula name="BUGGY_ADD_SUBFORMULA6" groupId="BUGGY_ADD_SUBFORMULA">
        <match>*X∨...</match>
        <replace>$Y∨*X</replace>
        <newFormula>Y</newFormula>
    </patternNewFormula>

    <patternNewFormula name="BUGGY_ADD_SUBFORMULA7" groupId="BUGGY_ADD_SUBFORMULA">
        <match>$X</match>
        <replace>$Y→$X</replace>
        <newFormula>Y</newFormula>
    </patternNewFormula>

    <patternNewFormula name="BUGGY_ADD_SUBFORMULA8" groupId="BUGGY_ADD_SUBFORMULA">
        <match>$X</match>
        <replace>$Y↔$X</replace>
        <newFormula>Y</newFormula>
    </patternNewFormula>


    <invertible name="BUGGY_SWAP_EQUIVALENCE_FOR_IMPLICATION" groupId="BUGGY_SWAP_EQUIVALENCE_IMPLICATION">
        <match>$X ↔ $Y</match>
        <replace>$X → $Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X ↔ Y</input>
                <expect>X → Y</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_SWAP_EQUIVALENCE_FOR_CONJUNCTION" groupId="BUGGY_SWAP_EQUIVALENCE_CONJUNCTION">
        <match>$X ↔ $Y</match>
        <replace>$X ∧ $Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X ↔ Y</input>
                <expect>X ∧ Y</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_SWAP_EQUIVALENCE_FOR_DISJUNCTION" groupId="BUGGY_SWAP_EQUIVALENCE_DISJUNCTION">
        <match>$X ↔ $Y</match>
        <replace>$X ∨ $Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X ↔ Y</input>
                <expect>X ∨ Y</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_SWAP_IMPLICATION_FOR_EQUIVALENCE" groupId="BUGGY_SWAP_EQUIVALENCE_IMPLICATION">
        <match>$X → $Y</match>
        <replace>$X ↔ $Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X → Y</input>
                <expect>X ↔ Y</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_SWAP_IMPLICATION_FOR_CONJUNCTION" groupId="BUGGY_SWAP_IMPLICATION_CONJUNCTION">
        <match>$X → $Y</match>
        <replace>$X ∧ $Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X → Y</input>
                <expect>X ∧ Y</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_SWAP_IMPLICATION_FOR_DISJUNCTION" groupId="BUGGY_SWAP_IMPLICATION_DISJUNCTION">
        <match>$X → $Y</match>
        <replace>$X ∨ $Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X → Y</input>
                <expect>X ∨ Y</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_SWAP_DISJUNCTION_FOR_EQUIVALENCE" groupId="BUGGY_SWAP_EQUIVALENCE_DISJUNCTION">
        <match>$X ∨ $Y</match>
        <replace>$X ↔ $Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X ∨ Y</input>
                <expect>X ↔ Y</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_SWAP_DISJUNCTION_FOR_IMPLICATION" groupId="BUGGY_SWAP_IMPLICATION_DISJUNCTION">
        <match>$X ∨ $Y</match>
        <replace>$X → $Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X ∨ Y</input>
                <expect>X → Y</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_SWAP_DISJUNCTION_FOR_CONJUNCTION" groupId="BUGGY_SWAP_DISJUNCTION_CONJUNCTION">
        <match>*X∨...</match>
        <replace>*X∧...</replace>
        <tests>
            <assertApplicationResult>
                <input>X ∨ Y</input>
                <expect>X ∧ Y</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_SWAP_CONJUNCTION_FOR_EQUIVALENCE" groupId="BUGGY_SWAP_EQUIVALENCE_CONJUNCTION">
        <match>$X ∧ $Y</match>
        <replace>$X ↔ $Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X ∧ Y</input>
                <expect>X ↔ Y</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_SWAP_CONJUNCTION_FOR_IMPLICATION" groupId="BUGGY_SWAP_IMPLICATION_CONJUNCTION">
        <match>$X ∧ $Y</match>
        <replace>$X → $Y</replace>
        <tests>
            <assertApplicationResult>
                <input>X ∧ Y</input>
                <expect>X → Y</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_SWAP_CONJUNCTION_FOR_DISJUNCTION" groupId="BUGGY_SWAP_DISJUNCTION_CONJUNCTION">
        <match>*X∧...</match>
        <replace>*X∨...</replace>
        <tests>
            <assertApplicationResult>
                <input>X ∧ Y</input>
                <expect>X ∨ Y</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_SWAP_BOX_FOR_DIAMOND">
        <match>☐$X</match>
        <replace>◇$X</replace>
        <tests>
            <assertApplicationResult>
                <input>☐X</input>
                <expect>◇X</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_SWAP_DIAMOND_FOR_BOX">
        <match>◇$X</match>
        <replace>☐$X</replace>
        <tests>
            <assertApplicationResult>
                <input>◇X</input>
                <expect>☐X</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_ADD_BOX">
        <match>$X</match>
        <replace>☐$X</replace>
        <tests>
            <assertApplicationResult>
                <input>X</input>
                <expect>☐X</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_ADD_DIAMOND">
        <match>$X</match>
        <replace>◇$X</replace>
        <tests>
            <assertApplicationResult>
                <input>X</input>
                <expect>◇X</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_REMOVE_BOX">
        <match>☐$X</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>☐X</input>
                <expect>X</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_REMOVE_DIAMOND">
        <match>◇$X</match>
        <replace>$X</replace>
        <tests>
            <assertApplicationResult>
                <input>◇X</input>
                <expect>X</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_REMOVE_BOX_FROM_FRONT_OF_DISJUNCTION" onlyPart="true">
        <match>☐(*X∨...)</match>
        <replace>(*X∨...)</replace>
    </invertible>

    <invertible name="BUGGY_REMOVE_DIAMOND_FROM_FRONT_OF_CONJUNCTION" onlyPart="true">
        <match>◇(*X∧...)</match>
        <replace>(*X∧...)</replace>
    </invertible>

    <childrenPattern name="BUGGY_PUSH_BOX_INTO_DISJUNCTION" onlyPart="true">
        <outer>($*∨...)</outer>
        <match>$X</match>
        <replace>☐$X</replace>
    </childrenPattern>

    <childrenPattern name="BUGGY_PUSH_DIAMOND_INTO_CONJUNCTION" onlyPart="true">
        <outer>($*∧...)</outer>
        <match>$X</match>
        <replace>◇$X</replace>
    </childrenPattern>

    <sequential name="BUGGY_DISTRIBUTE_BOX">
        <references>
            <reference name="BUGGY_REMOVE_BOX_FROM_FRONT_OF_DISJUNCTION"/>
            <reference name="BUGGY_PUSH_BOX_INTO_DISJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>☐(X ∨ Y)</input>
                <expect>☐X ∨ ☐Y</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <sequential name="BUGGY_DISTRIBUTE_DIAMOND">
        <references>
            <reference name="BUGGY_REMOVE_DIAMOND_FROM_FRONT_OF_CONJUNCTION"/>
            <reference name="BUGGY_PUSH_DIAMOND_INTO_CONJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>◇(X ∧ Y)</input>
                <expect>◇X ∧ ◇Y</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <invertible name="BUGGY_ADD_BOX_TO_FRONT_OF_DISJUNCTION" onlyPart="true">
        <match>(*X∨...)</match>
        <replace>☐(*X∨...)</replace>
    </invertible>

    <invertible name="BUGGY_ADD_DIAMOND_TO_FRONT_OF_CONJUNCTION" onlyPart="true">
        <match>(*X∧...)</match>
        <replace>◇(*X∧...)</replace>
    </invertible>

    <childrenPattern name="BUGGY_PULL_BOX_OUT_OF_DISJUNCTION" onlyPart="true">
        <outer>((☐$)*∨...)</outer>
        <match>☐$X</match>
        <replace>$X</replace>
    </childrenPattern>

    <childrenPattern name="BUGGY_PULL_DIAMOND_OUT_OF_CONJUNCTION" onlyPart="true">
        <outer>((◇$)*∧...)</outer>
        <match>◇$X</match>
        <replace>$X</replace>
    </childrenPattern>

    <sequential name="BUGGY_UNDISTRIBUTE_BOX">
        <references>
            <reference name="BUGGY_PULL_BOX_OUT_OF_DISJUNCTION"/>
            <reference name="BUGGY_ADD_BOX_TO_FRONT_OF_DISJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>☐X ∨ ☐Y</input>
                <expect>☐(X ∨ Y)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <sequential name="BUGGY_UNDISTRIBUTE_DIAMOND">
        <references>
            <reference name="BUGGY_PULL_DIAMOND_OUT_OF_CONJUNCTION"/>
            <reference name="BUGGY_ADD_DIAMOND_TO_FRONT_OF_CONJUNCTION"/>
        </references>
        <tests>
            <assertApplicationResult>
                <input>◇X ∧ ◇Y</input>
                <expect>◇(X ∧ Y)</expect>
            </assertApplicationResult>
        </tests>
    </sequential>

    <invertible name="BUGGY_PUSH_NEGATION_BOX" groupId="BUGGY_PUSH_NEGATION_MODAL_OPERATORS">
        <match>¬☐$X</match>
        <replace>☐¬$X</replace>
        <tests>
            <assertApplicationResult>
                <input>¬☐X</input>
                <expect>☐¬X</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_PUSH_NEGATION_DIAMOND" groupId="BUGGY_PUSH_NEGATION_MODAL_OPERATORS">
        <match>¬◇$X</match>
        <replace>◇¬$X</replace>
        <tests>
            <assertApplicationResult>
                <input>¬◇X</input>
                <expect>◇¬X</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_PULL_NEGATION_BOX" groupId="BUGGY_PULL_NEGATION_MODAL_OPERATORS">
        <match>☐¬$X</match>
        <replace>¬☐$X</replace>
        <tests>
            <assertApplicationResult>
                <input>☐¬X</input>
                <expect>¬☐X</expect>
            </assertApplicationResult>
        </tests>
    </invertible>

    <invertible name="BUGGY_PULL_NEGATION_DIAMOND" groupId="BUGGY_PULL_NEGATION_MODAL_OPERATORS">
        <match>◇¬$X</match>
        <replace>¬◇$X</replace>
        <tests>
            <assertApplicationResult>
                <input>◇¬X</input>
                <expect>¬◇X</expect>
            </assertApplicationResult>
        </tests>
    </invertible>
</transformations>